# 📘 암호 수학 1

## 📑 목차
1. 나눗셈과 가분성
2. 약수와 배수
3. 최대공약수와 서로소
4. 모듈로 연산
5. 법 n에 대해 합동
6. 소수, 합성수, 소인수분해, 서로소
7. 집합 Z_n과 Z_n*
8. 역원
9. 유클리드 알고리즘
10. 베주 항등식
11. 확장 유클리드 알고리즘
12. 곱셈의 역원 존재 판단
13. 곱셈의 역원과 확장 유클리드 알고리즘

## 🔢 나눗셈과 가분성
### 나눗셈
정수 \(a\)와 양의 정수 \(b\)에 대해, \(a\)를 \(b\)로 나누면 몫 \(q\)와 나머지 \(r\)가 유일하게 존재하여 \(a = bq + r\) (단, \(0 \leq r < b\))를 만족한다. 

예시: 22를 5로 나누면 몫은 4이고 나머지는 2이다. 

### 가분성 (Divisibility)
정수 \(a\)와 \(b\)에 대해, \(a\)가 \(b\)로 나누어질 때 \(b \mid a\)로 표기한다. 예를 들어, 10은 5로 나누어지므로 \(5 \mid 10\)이다. 반면, 11은 5로 나누어지지 않으므로 \(5 \nmid 11\)이다.

## 📏 약수와 배수
### 약수 (Divisor)와 배수 (Multiple)
정수 \(a\)와 \(b\)에 대해, \(a = bq\)인 정수 \(q\)가 존재하면 \(a\)는 \(b\)의 배수이고, \(b\)는 \(a\)의 약수이다.

예: \(10 = 5 \times 2\)에서 5는 10의 약수이고, 10은 5의 배수이다. 

## 📐 최대공약수와 서로소
### 최대공약수 (Greatest Common Divisor, GCD)
두 정수 \(a\)와 \(b\)의 최대공약수는 \(a\)와 \(b\)의 공통 약수 중 가장 큰 수이다. 예: \(36\)과 \(27\)의 최대공약수는 \(9\)이다.

### 서로소 (Coprime)
두 정수 \(a\)와 \(b\)의 최대공약수가 \(1\)이면 \(a\)와 \(b\)는 서로소이다. 예: \(16\)과 \(27\)은 서로소이다.

## 🧮 모듈로 연산
정수 \(a\)와 양의 정수 \(n\)에 대해, \(a\)를 \(n\)으로 나눈 나머지를 \(a \mod n\)으로 표기한다. 예: \(20 \mod 3 = 2\).

## 🔢 법 n에 대해 합동
정수 \(a\)와 \(b\)가 \(n\)으로 나눈 나머지가 같으면 \(a \equiv b \mod n\)로 표기한다. 예: \(20 \equiv 14 \mod 3\).

## 🔢 소수, 합성수, 소인수분해, 서로소
### 소수 (Prime Number)
1보다 큰 정수 중 1과 자신만을 약수로 갖는 수. 예: \(2, 3, 5, 7, 11\).

### 합성수 (Composite Number)
1보다 큰 정수 중 소수가 아닌 수. 예: \(4, 6, 8, 9, 10\).

### 소인수분해 (Prime Factorization)
1보다 큰 정수를 소수들의 곱으로 표현하는 것. 예: \(6 = 2 \times 3\).

## 🔢 집합 \(Z_n\)과 \(Z_n^*\)
### 집합 \(Z_n\)
법 \(n\)에 대한 모든 최소 잔여들의 집합. 예: \(Z_6 = \{0, 1, 2, 3, 4, 5\}\).

### 집합 \(Z_n^*\)
\(n\)과 서로소인 \(1\)부터 \(n-1\)까지의 수들의 집합. 예: \(Z_6^* = \{1, 5\}\).

## 🔄 역원
### 덧셈의 역원 (Additive Inverse)
\(a + b \equiv 0 \mod n\)이면 \(b\)는 \(a\)의 덧셈 역원이다. 예: \(2 + (-2) \equiv 0 \mod 4\).

### 곱셈의 역원 (Multiplicative Inverse)
\(a \times b \equiv 1 \mod n\)이면 \(b\)는 \(a\)의 곱셈 역원이다. 예: \(3 \times 7 \equiv 1 \mod 10\).

## 🔄 유클리드 알고리즘
두 정수 \(a\)와 \(b\)의 최대공약수를 구하는 알고리즘. 
예:
- \(gcd(36, 28) = gcd(28, 8) = gcd(8, 4) = gcd(4, 0) = 4\)
- \(gcd(24, 30) = gcd(30, 24) = gcd(24, 6) = gcd(6, 0) = 6\)

### 유클리드 알고리즘의 증명
유클리드 알고리즘은 다음의 성질을 바탕으로 동작합니다:
- \(a = bq + r\)일 때, \(gcd(a, b) = gcd(b, r)\).
- 이 과정을 반복하면 결국 나머지가 0이 되는 순간 최대공약수를 구할 수 있습니다.

## 📜 베주 항등식 (Bézout’s Identity)
정수 \(a\)와 \(b\)의 최대공약수는 \(a\)와 \(b\)의 정수 계수의 선형 결합으로 표현될 수 있다. 즉, \(d = gcd(a, b)\)라면 정수 \(x\)와 \(y\)가 존재하여 \(ax + by = d\)를 만족한다.

### 베주 항등식의 증명
베주 항등식은 다음과 같이 증명할 수 있습니다:
1. 유클리드 알고리즘을 통해 \(d = gcd(a, b)\)를 구합니다.
2. 각 단계에서 \(r = a - bq\) 형태의 등식을 사용하여 \(d\)를 표현합니다.
3. 마지막 단계에서 \(d = ax + by\) 형태로 나타낼 수 있습니다.

## 🔄 확장 유클리드 알고리즘
확장 유클리드 알고리즘은 베주 항등식의 계수를 구하는 알고리즘이다.  
예:
- \(gcd(56, 34) = 2\)는 \(56 \times (-3) + 34 \times 5 = 2\)로 표현된다.

```python
def egcd(a, b):
    r1, r2 = a, b
    s1, s2 = 1, 0
    t1, t2 = 0, 1
    while r2 > 0:
        q = r1 // r2
        r = r1 - q * r2
        r1, r2 = r2, r
        s = s1 - q * s2
        s1, s2 = s2, s
        t = t1 - q * t2
        t1, t2 = t2, t
    return (r1, s1, t1)
print(egcd(56, 34))
```

### 🔄 곱셈의 역원 존재 판단
정수 𝑎와 𝑛이 서로소이면, 𝑎는 법 𝑛에 대한 곱셈의 역원을 갖는다.  
> 예: 7은 법 10에서 곱셈의 역원 3을 갖는다.

증명
- a와 𝑛이 서로소라면 𝑔𝑐𝑑(𝑎,𝑛) = 1이다.
- 확장 유클리드 알고리즘을 통해 𝑎𝑥 + 𝑛𝑦 = 1 을 만족하는 정수 𝑥와 𝑦가 존재한다.
- 따라서 𝑎𝑥 ≡ 1 mod 𝑛 이므로 𝑥가 𝑎의 곱셈의 역원이다.

### 🔄 곱셈의 역원과 확장 유클리드 알고리즘
확장 유클리드 알고리즘을 사용하여 곱셈의 역원을 찾을 수 있다.  
예:

```python
def find_inverse(a, n):
    g, x, y = egcd(a, n)
    if g != 1:
        raise Exception('역원이 존재하지 않습니다')
    else:
        return x % n

print(find_inverse(7, 10))
```
