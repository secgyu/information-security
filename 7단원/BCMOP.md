# 📘 블록 암호 모드 (Block Cipher Mode of Operation)

## 📑 목차
1. 블록 암호 시스템 운영 모드 개요
2. ECB (Electronic Code Book)
3. CBC (Cipher Block Chaining)
4. CFB (Cipher Feedback)
5. OFB (Output Feedback)
6. CTR (Counter)
7. 패딩 (Padding)
8. 참고 문헌

## 블록 암호 시스템 운영 모드 개요
블록 암호 시스템은 하나의 고정 크기 블록에 대해 동작합니다. 예를 들어, DES는 64비트 블록을, AES는 128비트 블록을 사용합니다. 그러나 실제 평문 길이는 가변적이므로, 대부분 블록 크기를 초과하는 데이터를 암호화, 복호화할 필요가 있습니다. 임의 길이 평문에 대해 블록 암호 시스템을 반복 적용하는 방법이 필요하며, 이를 위해 블록 암호 시스템 운영 모드(Block cipher mode of operation)가 사용됩니다.

- **주요 운영 모드**:
  - ECB (Electronic Code Book)
  - CBC (Cipher Block Chaining)
  - CFB (Cipher Feedback)
  - OFB (Output Feedback)
  - CTR (Counter)

## ECB (Electronic Code Book)
### 📜 개요
ECB 모드는 가장 단순한 블록 암호 운영 모드입니다. 각 블록이 독립적으로 암호화되기 때문에 동일한 평문 블록은 항상 동일한 암호문 블록으로 암호화됩니다.

- **암호화**: 블록 크기 n 비트보다 큰 평문 메시지는 n 비트 단위의 평문 블록으로 분할되어 각각 암호화됩니다.
- **복호화**: 각 암호문 블록은 독립적으로 복호화되어 평문 블록이 생성됩니다.
- **패딩**: 마지막 평문 블록이 블록 크기보다 작은 경우 패딩이 적용됩니다.
- **오류 전파**: 전송 중 특정 암호문 블록의 단일 비트 오류 발생 시 해당 블록에만 영향이 있으며, 다른 블록들로의 오류 전파는 없습니다.
- **병렬 처리**: 블록 간 독립성이 있으므로 암호화 및 복호화 시 병렬 처리가 가능합니다.
- **단점**: 동일한 평문 블록은 동일한 암호문 블록으로 생성되어 평문의 통계적 정보가 공격자에게 노출될 수 있으며, 암호문 블록의 삭제, 순서 변경 등의 공격이 가능합니다.

### 📊 예시
평문: P1 P2 P3 P4  
암호문: C1 C2 C3 C4  

암호화: C1 = E(P1), C2 = E(P2), ...  
복호화: P1 = D(C1), P2 = D(C2), ...  

## CBC (Cipher Block Chaining)
### 📜 개요
CBC 모드는 각 평문 블록을 직전 암호문 블록과 XOR한 결과에 대해 블록 암호화를 적용합니다. 최초 평문 블록의 경우 IV(Initialization Vector)가 직전 암호문 블록 대신 사용됩니다.

- **암호화**: P_i XOR C_{i-1}를 암호화하여 C_i를 생성합니다. C_0은 IV로 설정합니다.
- **복호화**: C_i를 복호화한 결과를 C_{i-1}과 XOR하여 P_i를 생성합니다.
- **오류 전파**: 전송 중 특정 암호문 블록 내 단일 비트 오류 발생 시, 수신 측 복호화를 통해 얻어지는 대응하는 평문과 직후 평문에 오류가 발생하며, 이후 평문 블록에는 오류 전파가 없습니다.
- **병렬 처리**: 암호화 시 병렬 처리 불가, 복호화 시 암호문 블록들이 준비되어 있으면 병렬 처리 가능.
- **특징**: 동일한 내용 블록들도 서로 다른 암호문 블록들로 변환됩니다.

### 📊 예시
평문: P1 P2 P3 P4  
암호문: C1 C2 C3 C4  

암호화: C1 = E(P1 ⊕ IV), C2 = E(P2 ⊕ C1), ...  
복호화: P1 = D(C1) ⊕ IV, P2 = D(C2) ⊕ C1, ...  

## CFB (Cipher Feedback)
### 📜 개요
CFB 모드는 블록 암호 시스템의 전송 단위를 유연하게 설정할 수 있으며, 평문 메시지는 세그먼트로 분할됩니다. 각 세그먼트는 블록 암호 시스템의 출력과 XOR 연산을 통해 암호화됩니다.

- **전송 단위**: CFB 모드의 전송 단위 s 비트는 블록 크기 n 보다 작게 설정할 수 있습니다.
- **암호화**: 직전 암호문 블록을 블록 암호화하여 생성된 출력의 최상위 s 비트와 평문 세그먼트를 XOR하여 암호문 세그먼트를 생성합니다.
- **복호화**: 직전 암호문 블록을 블록 암호화하여 생성된 출력의 최상위 s 비트와 암호문 세그먼트를 XOR하여 평문 세그먼트를 생성합니다.
- **패딩 불필요**: 평문 세그먼트 크기 s가 원하는 데이터 단위(예: 8 bits)로 고정 설정된 경우 패딩이 필요 없습니다.
- **오류 전파**: 전송 중 특정 암호문 세그먼트 내 단일 비트 오류가 발생한 경우, 복호화된 평문 세그먼트 내에서도 동일 위치의 단일 비트 오류가 발생하며, 이후 복호화되는 평문에도 영향을 미칩니다.
- **특징**: 암호화 및 복호화를 위해 블록 암호 시스템의 암호화 모듈만 사용됩니다.

### 📊 예시
평문: P1 P2 P3 P4  
암호문: C1 C2 C3 C4  

암호화: C1 = P1 ⊕ E(IV), C2 = P2 ⊕ E(C1), ...  
복호화: P1 = C1 ⊕ E(IV), P2 = C2 ⊕ E(C1), ...  

## OFB (Output Feedback)
### 📜 개요
OFB 모드는 블록 암호 시스템의 출력을 다음 블록의 입력으로 사용하는 방식입니다. 암호화와 복호화 과정에서 동일한 연산이 사용됩니다.

- **암호화**: 직전 출력을 블록 암호화한 결과와 평문 블록을 XOR하여 암호문 블록을 생성합니다. 최초 입력은 IV 값을 사용합니다.
- **복호화**: 직전 출력을 블록 암호화한 결과와 암호문 블록을 XOR하여 평문 블록을 생성합니다.
- **패딩 불필요**: 암호화 블록 크기가 n 비트이고, 마지막 평문 블록이 m 비트인 경우, 암호화 출력의 최상위 m 비트들만 취하여 마지막 평문 블록과 XOR 수행.
- **오류 전파**: 전송 중 암호문 블록 내 단일 비트 오류 발생 시, 복호화된 평문 블록 내 동일 위치 비트에만 영향을 미치며 이후 평문 블록에는 영향 없음.
- **특징**: 암호화 및 복호화를 위해 블록 암호 시스템의 암호화 모듈만 사용됩니다.

### 📊 예시
평문: P1 P2 P3 P4  
암호문: C1 C2 C3 C4  

암호화: C1 = P1 ⊕ E(IV), C2 = P2 ⊕ E(O1), ...  
복호화: P1 = C1 ⊕ E(IV), P2 = C2 ⊕ E(O1), ...  

## CTR (Counter)
### 📜 개요
CTR 모드는 카운터 값을 블록 암호화하여 암호문을 생성합니다. 각 블록마다 카운터 값이 1씩 증가합니다.

- **암호화**: 카운터를 블록 암호화한 결과와 평문 블록을 XOR하여 암호문 블록을 생성합니다.
- **복호화**: 카운터를 블록 암호화한 결과와 암호문 블록을 XOR하여 평문 블록을 생성합니다.
- **카운터**: 최초 초기화된 값이 사용되며, 다음 블록 처리 시 그 값을 1만큼 증가시킵니다.
- **패딩 불필요**: 암호화 블록 크기가 \(n\) 비트이고, 마지막 평문 블록이 \(m\) 비트인 경우, 카운터를 암호화한 결과의 최상위 \(m\) 비트들만 취하여 마지막 평문 블록과 XOR 수행.
- **오류 전파**: 전송 중 암호문 블록 내 단일 비트 오류 발생 시, 복호화된 평문 블록 내 동일 위치 비트에만 영향을 미칩니다.
- **특징**: 암호화 및 복호화를 위해 블록 암호 시스템의 암호화 모듈만 사용됩니다.

### 📊 예시
평문: P1 P2 P3 P4  
암호문: C1 C2 C3 C4  

암호화: C1 = P1 ⊕ E(CTR1), C2 = P2 ⊕ E(CTR2), ...  
복호화: P1 = C1 ⊕ E(CTR1), P2 = C2 ⊕ E(CTR2), ...  

## 패딩 (Padding)
패딩은 블록 크기를 맞추기 위해 평문에 추가되는 데이터입니다. 블록 암호화에서 마지막 블록이 블록 크기보다 작을 때 사용됩니다.

### 🗃️ PKCS#7 패딩
PKCS#7 패딩은 블록 크기 \(K\) 바이트에 맞추기 위해, 메시지 크기 \(L\) 바이트에 대해 추가되는 바이트의 수를 지정합니다.
- \(L \mod K = K-1\)이면 1의 바이트 표현 1개를 메시지 끝에 추가.
- \(L \mod K = K-2\)이면 2의 바이트 표현 2개를 메시지 끝에 추가.
- ...
- \(L \mod K = 0\)이면 \(K\)의 바이트 표현 \(K\)개를 메시지 끝에 추가.

### 📊 예시
- 블록 크기 8 바이트, 메시지 M=AABBCC → 패딩 후 → M=AABBCC0505050505
- 블록 크기 8 바이트, 메시지 M=1122334455667788 → 패딩 후 → M=11223344556677880808080808080808

### 🗃️ 비트 패딩
메시지 끝에 비트 1을 부착한 후 블록 크기의 배수가 될 때까지 비트 0을 추가합니다.
- 블록 크기 8 바이트, 메시지 M=AABBCC → 패딩 후 → M=AABBCC8000000000
- 블록 크기 8 바이트, 메시지 M=1122334455667788 → 패딩 후 → M=11223344556677888000000000000000

## 📚 참고 문헌
- [NIST Special Publication 800-38a](https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-38a.pdf)
