# 📦 블록 암호 기술

## 📜 개요
블록 암호는 고정된 크기의 블록 단위로 데이터를 암호화하는 대칭키 암호화 기술입니다. 블록 암호 기술은 대치(Substitution)와 전치(Transposition) 방식을 결합하여 데이터 보안성을 높이는 데 중점을 둡니다.

## 🔑 대칭키 암호기술
블록 암호는 대칭키 암호화 방식을 사용하여, 동일한 비밀 키를 사용하여 데이터를 암호화하고 복호화합니다.

- **암호화**: n-bit 평문 → n-bit 암호문 (k-bit 키 사용)
- **복호화**: n-bit 암호문 → n-bit 평문 (k-bit 키 사용)

### 📌 주요 요소
- **P-box**: 전치 네트워크, 비트 위치를 재배열하여 확산(Diffusion) 특성을 제공
- **S-box**: 대치 네트워크, 입력 비트를 다른 출력 비트로 매핑하여 혼돈(Confusion) 특성을 제공

## 🔄 Substitution vs. Transposition
- **Substitution**: 각 비트를 다른 비트로 대체하여 암호화
- **Transposition**: 비트의 위치를 재배열하여 암호화

### 예제 문제
64-bit 블록 암호에서 암호문 내 비트 1의 개수가 10개일 때, 해당 평문을 찾기 위해 몇 개의 다른 평문을 검사해야 하는가?
- Substitution: 모든 가능한 64-bit 평문 블록을 시도해야 함 (2^64 개)
- Transposition: 비트 1의 개수가 동일한 평문 블록만 시도 (64! / (10! * 54!) ≈ 151.5 x 10^9 개)

## 📐 Full-size vs. Partial-size Key Cipher
- **Full-size Key Cipher**: 평문과 암호문 간 가능한 모든 매핑을 사용하기에 충분한 크기의 키 사용
  - 예: 3-bit 블록 암호화에서 가능한 매핑 수는 3! = 6, 키 크기는 log2(6) ≈ 3 bits
- **Partial-size Key Cipher**: 일부 매핑만 사용
  - 예: DES는 64-bit 블록 암호화에 56-bit 키 사용 (2^56 개 매핑)

## 🔄 Modern Block Cipher Components
- **Straight P-box**: 입력 비트를 고정된 위치로 재배열
- **Compression P-box**: n개의 입력을 m개의 출력으로 축소 (n > m)
- **Expansion P-box**: n개의 입력을 m개의 출력으로 확장 (n < m)
- **S-box**: 비트 대치 테이블

### 📌 예제
- **Straight P-box**:  
  입력: 1 2 3 4 5  
  출력: [2 4 5 1 3]


## 🔄 Product Cipher
- **Product Cipher**: Claude Shannon에 의해 소개됨. 대치와 전치를 결합하여 보안을 강화
- 예: DES, AES

## 🔀 Diffusion and Confusion
- **Diffusion (확산)**: 암호문과 평문 간의 상관성을 숨겨 통계 분석을 통한 공격을 방지
- **Confusion (혼돈)**: 암호문과 키 간의 상관성을 숨겨 키 추론을 방지

## 🔄 Feistel Cipher 및 Non-Feistel Cipher
### Feistel Cipher
Feistel 암호는 암호화와 복호화가 동일한 구조를 가지며, 라운드를 반복하면서 각 라운드에서 키와 데이터가 결합되는 구조입니다. 이 구조는 가역적(invertible) 요소와 비가역적(non-invertible) 요소를 모두 사용합니다.

#### 주요 특징
- **라운드**: 각 라운드는 데이터의 일부를 다른 부분과 혼합하는 함수 \( f \)를 사용하여 처리됩니다.
- **가역성**: 암호화와 복호화 과정이 서로의 역(inverse)이며, 동일한 키 스케줄을 사용하여 복호화가 가능합니다.
- **예시**: DES (Data Encryption Standard)

#### 암호화 과정
1. 평문을 두 개의 절반으로 나눕니다: L0와 R0.
2. 각 라운드에서 다음과 같이 처리합니다:
 - Li+1 = Ri
 - Ri+1 = Li XOR f(Ri, Ki)
3. 최종 라운드의 출력은 암호문이 됩니다.

#### 복호화 과정
1. 암호문을 두 개의 절반으로 나눕니다: Ln과 Rn.
2. 각 라운드에서 다음과 같이 처리합니다:
 - Ri = Li+1
 - Li = Ri+1 XOR f(Li+1, Ki)
3. 최종 라운드의 출력은 평문이 됩니다.

### Non-Feistel Cipher
Non-Feistel 암호는 모든 구성 요소가 가역적(invertible)인 구조를 가지며, 일반적으로 Feistel 암호보다 더 단순한 구조를 가지고 있습니다.

#### 주요 특징
- **가역성**: 모든 구성 요소가 가역적이기 때문에, 암호화와 복호화가 동일한 과정을 거치면서 반대 순서로 진행됩니다.
- **예시**: AES (Advanced Encryption Standard)

#### 암호화 과정
1. 평문을 블록 단위로 나눕니다.
2. 각 라운드에서 다음과 같이 처리합니다:
 - 바이트 치환(SubBytes): 각 바이트를 S-box를 통해 대체합니다.
 - 행 이동(ShiftRows): 각 행을 순환 이동합니다.
 - 열 혼합(MixColumns): 각 열을 고정된 다항식으로 곱합니다.
 - 라운드 키 추가(AddRoundKey): 라운드 키와 XOR 연산을 수행합니다.
3. 최종 라운드에서는 열 혼합을 제외한 나머지 연산을 수행하여 암호문을 생성합니다.

#### 복호화 과정
1. 암호문을 블록 단위로 나눕니다.
2. 각 라운드에서 다음과 같이 처리합니다:
 - 라운드 키 추가(AddRoundKey): 라운드 키와 XOR 연산을 수행합니다.
 - 열 혼합(Inverse MixColumns): 각 열을 역다항식으로 곱합니다.
 - 행 이동(Inverse ShiftRows): 각 행을 반대 방향으로 순환 이동합니다.
 - 바이트 치환(Inverse SubBytes): 각 바이트를 역 S-box를 통해 대체합니다.
3. 최종 라운드에서는 열 혼합을 제외한 나머지 연산을 수행하여 평문을 복호화합니다.
